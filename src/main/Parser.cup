package main;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;

parser code 
{:
    public static Node father;
    public int cont = 0;
    public static int errores = 0;

    public void syntax_error(Symbol s){ 
       System.out.println("Error Sintáctico en la Línea " + (s.left) +
        " Columna "+s.right+ ". No se esperaba este componente: " +s.value+".");
       System.out.println("Sintaxis truena");
    } 

    /* public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println("CUP detecto un error de syntaxis en " + s.left + " column " + s.right);
    } */
:}


terminal String BOOL, CHAR, INT, EMPTY;
terminal MAIN, IF, THEN, ELSE, FOR, TO, WHILE, SWITCH, CASE, DEFAULT, FUNCTION, COMEBACK; 
terminal NUMBER, BOOLEAN, CHARACTER, INPUT, OUTPUT, OPREL, SUM, RES, MULT, CALL; 
terminal DIV, MOD, SEMICOLON, COLON, COMMA, PARDER, PARIZQ, BRACKETDER, BRACKETIZQ; 
terminal SBRACKETDER, SBRACKETIZQ, ASSIGNMENT, ID, DELIMETER, ARRAY;


// Principals non terminals
non terminal program, main, body, b_body;
non terminal proposition;
non terminal function;
non terminal function_list;

non terminal parameter;
non terminal b_parameter;

non terminal functionCall;
non terminal funCall_parameter;
non terminal b_funCall_parameter;

// Asignation and declaration
non terminal type;
non terminal array_type;
non terminal simpleDeclaration;
non terminal declaration_assign;
non terminal assignment;
non terminal value;
non terminal aritmetic_expression ;
non terminal b_aritmetic_expression;
non terminal c_aritmetic_expression;
non terminal signo;
non terminal array_value;

// Statements
non terminal whileStatement;
non terminal ifStatement;
non terminal desicion; // Desición para While y If
non terminal elseIf;
non terminal inputStatement;
non terminal forStatement;
non terminal switchStatement;
non terminal switch_body;
non terminal case_switch;
non terminal b_case_switch;
non terminal return;

start with program;


program ::= main:m function_list:fl
        {:      // CURRENT NODE
                Node node = new Node();
                node.setTag("INIT");
                node.setId(parser.cont);  
                parser.cont++;
                
                // MAIN
                node.setChild( (Node) m );

                // FUNCTION_LIST
                if(fl!=null) node.setChild((Node)fl);

                parser.father = node;
                RESULT = node;
        :};

main ::= FUNCTION MAIN:m PARIZQ PARDER ASSIGNMENT BRACKETIZQ body:b BRACKETDER
        {:      // CURRENT NODE
                Node node = new Node();
                node.setTag("MAIN");
                node.setId(parser.cont);
                parser.cont++;

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setId(parser.cont);
                id.setValue((String) m);
                node.setChild(id);

                // BODY
                if (b!=null) node.setChild( (Node) b );
                

                parser.father = node;
                RESULT = node;
        :};

function_list ::= function:f function_list:fl
        {:      
                // CURRENT NODE
                Node node = new Node();
                node.setTag("FUNCTION_LIST");
                node.setId(parser.cont);
                parser.cont++;

                // FUNCTION
                node.setChild((Node)f);

                if(fl!=null) node.setChild( ((Node)fl).getChildren() );                      
                
                parser.father = node;
                RESULT = node;
        :} 
        | {:

        :}; // Este GLC permite múltiples funciones
function ::= FUNCTION ID:i PARIZQ parameter:p PARDER ASSIGNMENT BRACKETIZQ body:b BRACKETDER
        {:      // CURRENT NODE
                Node node = new Node();
                node.setTag("FUNCTION");
                node.setId(parser.cont);
                parser.cont++;

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setId(parser.cont);
                parser.cont++;
                id.setValue( (String) i);
                node.setChild(id);

                // PARAMETER
                if (p!=null) node.setChild( (Node) p );
                
                // BODY
                if (b!=null) node.setChild( (Node) b );
                
                parser.father = node;
                RESULT = node;
        :}
        | FUNCTION ID:i PARIZQ parameter:p PARDER ASSIGNMENT type:t BRACKETIZQ body:b return:r BRACKETDER
        {:
                // CURRENT NODE
                Node node = new Node();
                node.setTag("FUNCTION_WITH_RETURN");
                node.setId(parser.cont);
                parser.cont++;

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setId(parser.cont);
                parser.cont++;
                id.setValue( (String) i);
                node.setChild(id);
                
                // PARAMETER
                if (p!=null) node.setChild( (Node) p );
                
                // RETURN TYPE
                node.setChild( (Node) t );

                // BODY
                if (b!=null) {
                        Node n = (Node)b;
                        n.setChild((Node)r);
                        node.setChild(n);
                }else{
                        Node bo = new Node();
                        bo.setTag("BODY");
                        bo.setId(parser.cont);
                        parser.cont++;
                        bo.setChild((Node)r);
                        node.setChild(bo);
                }

                RESULT = node;
        :};

parameter ::= b_parameter:b parameter:p
        {:
                // PROPOSITION
                Node node = new Node();
                node.setTag("PARAMETER_LIST");
                node.setId(parser.cont);
                parser.cont++;

                // PROPOSITION
                node.setChild( (Node) b );
        
                if(p!=null) node.setChild( ((Node)p).getChildren() );

                parser.father = node;
                RESULT = node;
        :}
        | {:/*vacío*/:};        // GLC para el parámetro que contienen las funciones  
b_parameter ::= ID:i COLON type:t 
        {:
                Node node = new Node();
                node.setTag("PARAMETER");
                node.setId(parser.cont++);
                parser.cont++;

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue( (String) i);
                id.setId(parser.cont++);
                parser.cont++;
                
                node.setChild(id);

                // TYPE
                node.setChild( (Node)t);

                RESULT = node;
        :}
        | ID:i COLON type:t COMMA 
        {:
                Node node = new Node();
                node.setTag("PARAMETER");
                node.setId(parser.cont++);
                parser.cont++;

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue( (String) i);
                id.setId(parser.cont++);
                parser.cont++;
                
                node.setChild(id);

                // TYPE
                node.setChild( (Node)t);

                RESULT = node;
        :};

body ::= proposition:p body:b
        {:
                // PROPOSITION
                Node node = new Node();
                node.setTag("BODY");
                node.setId(parser.cont);
                parser.cont++;

                // PROPOSITION
                node.setChild( (Node) p );
                
                if(b!=null){
                        node.setChild( ((Node)b).getChildren() );
                }
                parser.father = node;
                RESULT = node;
        :}
        | {:/*Vacío*/:}; // Este GLC permite múltiples proposiciones   
proposition ::= type:t ID:i
        {:      
                // TYPE ID
                Node node = new Node();
                node.setTag("SIMPLE_DECLARATION");
                node.setId(parser.cont);
                parser.cont++;

                // TYPE
                node.setChild( (Node) t);

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue((String)i);
                id.setId(parser.cont);
                parser.cont++;

                node.setChild(id);

                parser.father = node;
                RESULT = node;
        :} 
        | type:t ID:i ASSIGNMENT:a value:v
        {:
                // TYPE ID = VALUE
                Node node = new Node();
                node.setTag("DECLARATION_ASSIGNATION");
                node.setId(parser.cont);
                parser.cont++;

                // TYPE
                node.setChild( (Node) t);

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue( (String) i);
                id.setId(parser.cont);
                parser.cont++;
                node.setChild(id);

                // ASSIGNMENT
                Node as = new Node();
                as.setTag("ASSIGNMENT");
                as.setValue( (String) a);
                as.setId(parser.cont);
                parser.cont++;
                node.setChild(as);

                // VALUE
                node.setChild( (Node) v);

                parser.father = node;
                RESULT = node;     
        :}
        | ID:i ASSIGNMENT:a value:v
        {:
                // ID = VALUE
                Node node = new Node();
                node.setTag("ASSIGNMENT");
                node.setId(parser.cont);
                parser.cont++;

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue( (String) i);
                id.setId(parser.cont);
                node.setChild(id);

                // ASSIGNMENT
                Node as = new Node();
                as.setTag("ASSIGNMENT");
                as.setValue( (String) a);
                as.setId(parser.cont);
                parser.cont++;
                node.setChild(as);

                // VALUE
                node.setChild( (Node) v);

                parser.father = node;
                RESULT = node;   
        :}
        | CALL ID:i PARIZQ PARDER 
        {:
                // CALL FUNCTION()
                Node node = new Node();
                node.setTag("FUNCTION_CALL");
                node.setId(parser.cont);
                parser.cont++;

                // CALL
                Node call = new Node();
                call.setTag("CALL");
                call.setId(parser.cont);
                parser.cont++;
                node.setChild(call);

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue((String)i);
                id.setId(parser.cont);
                parser.cont++;
                node.setChild(id);

                parser.father = node;
                RESULT = node;   
        :}
        | CALL ID:i PARIZQ funCall_parameter:f PARDER
        {:
                // CALL FUNCTION( VALUE, VALUE2, VALUE3 )
                Node node = new Node();
                node.setTag("FUNCTION_CALL");
                node.setId(parser.cont);
                parser.cont++;

                // CALL
                Node call = new Node();
                call.setTag("CALL");
                call.setId(parser.cont);
                parser.cont++;
                node.setChild(call);

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue((String)i);
                id.setId(parser.cont);
                parser.cont++;
                node.setChild(id);

                // PARAMETERS
                node.setChild( (Node) f);
                
                parser.father = node;
                RESULT = node; 
        :}
        | OUTPUT:ou PARIZQ value:v PARDER 
        {:      
                // output(ID)
                Node node = new Node();
                node.setTag("OUTPUT_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // OUTPUT
                Node output = new Node();
                output.setTag("OUTPUT");
                output.setValue( (String) ou);
                output.setId(parser.cont);
                parser.cont++;
                node.setChild(output);

                // VALUE
                node.setChild((Node)v);

                parser.father = node;
                RESULT = node;
        :}
        | ID:i ASSIGNMENT:a INPUT:ip PARIZQ PARDER 
        {:
                // id = input()
                Node node = new Node();
                node.setTag("INPUT_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setId(parser.cont);
                id.setValue( (String) i);
                parser.cont++;
                node.setChild(id);

                // ASSIGNMENT
                Node assignment = new Node();
                assignment.setTag("ASSIGNMENT");
                assignment.setValue( (String) a);
                assignment.setId(parser.cont);
                parser.cont++;
                node.setChild(assignment);

                // INPUT
                Node input = new Node();
                input.setTag("INPUT");
                input.setValue( (String) ip);
                input.setId(parser.cont);
                parser.cont++;
                node.setChild(input);

                parser.father = node;
                RESULT = node;
        :}
        | ifStatement: i
        {:
                RESULT = (Node)i;
        :}
        | WHILE:w PARIZQ desicion:d PARDER THEN:t BRACKETIZQ body:b BRACKETDER 
        {:
                // while () then {}
                Node node = new Node();
                node.setTag("WHILE_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // WHILE
                Node wh_s = new Node();
                wh_s.setTag("WHILE");
                wh_s.setValue( (String) w);
                wh_s.setId(parser.cont);
                parser.cont++;
                node.setChild(wh_s);

                // DESICION
                node.setChild((Node)d);

                // THEN
                Node th = new Node();
                th.setTag("THEN");
                th.setValue( (String) t);
                th.setId(parser.cont);
                parser.cont++;
                node.setChild(th);

                // BODY
                if (b!=null) node.setChild( (Node) b );

                parser.father = node;
                RESULT = node;
        :}
        | forStatement:f 
        {:
                RESULT = (Node)f;
        :}
        | switchStatement 
        {:      
                Node node = new Node();
                node.setTag("SWTICH");
                node.setId(parser.cont);
                parser.cont++;

                // SIMPLE_DECLARATION
                // node.setChild( (Node) sp);
                node.setChild(new Node(":V"));

                parser.father = node;
                RESULT = node;
        :} ;      // Este GLC contiene los diferentes statements

funCall_parameter ::= b_funCall_parameter:b funCall_parameter:fl
        {:
                Node node = new Node();
                node.setTag("FUNCTION_CALL_PARAMETERS");
                node.setId(parser.cont);
                parser.cont++;

                node.setChild( (Node)b);
                
                node.setChild( ((Node)fl).getChildren() );

                RESULT = node;
        :}
        | value:v
        {:
                Node node = new Node();
                node.setTag("FUNCTION_CALL_PARAMETERS");
                node.setId(parser.cont);
                parser.cont++;

                node.setChild((Node)v);
        
                RESULT = node;
        :};
b_funCall_parameter ::= value:v COMMA 
        {:      
                RESULT = (Node) v;
        :};

signo ::= SUM
        | RES
        | DIV
        | MULT
        | MOD;
value ::= ID:id
        {:
                Node node = new Node();
                node.setTag("ID");
                node.setValue((String)id);
                node.setId(parser.cont);
                parser.cont++;

                RESULT = node;
        :}
        | BOOL:b
        {:
                Node node = new Node();
                node.setTag("BOOLEAN");
                node.setValue((String)b);
                node.setId(parser.cont);
                parser.cont++;

                RESULT = node;
        :}
        | CHAR:c
        {:
                Node node = new Node();
                node.setTag("CHARACTER");
                node.setValue((String)c);
                node.setId(parser.cont);
                parser.cont++;

                RESULT = node;
        :}
        | EMPTY:e
        {:
                Node node = new Node();
                node.setTag("EMPTY");
                node.setValue((String)e);
                node.setId(parser.cont);
                parser.cont++;

                RESULT = node;
        :}                
        | array_value:av
        {:

        :}
        | INT:i
        {:
                Node node = new Node();
                node.setTag("NUMBER");
                node.setValue((String)i);
                node.setId(parser.cont);
                parser.cont++;

                RESULT = node;
        :};              // Tipo de valor que pueda contener una expresión

/* aritmetic_expression ::= INT b_aritmetic_expression
        | PARIZQ INT b_aritmetic_expression PARDER c_aritmetic_expression;
b_aritmetic_expression ::= signo aritmetic_expression
        | {::} ;

c_aritmetic_expression ::= b_aritmetic_expression; */

forStatement ::= 
        FOR:f PARIZQ ID ASSIGNMENT INT TO INT DELIMETER INT PARDER THEN:t BRACKETIZQ body:b BRACKETDER
        {:
                // for ( id = 0 to 10 | 1) then {}
                Node node = new Node();
                node.setTag("FOR_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // FOR
                Node for_s = new Node();
                for_s.setTag("FOR");
                for_s.setValue( (String) f);
                for_s.setId(parser.cont);
                parser.cont++;
                node.setChild(for_s);

                // FOR_PARAMETERS
                // node.setChild((Node)d);

                // THEN
                Node th = new Node();
                th.setTag("THEN");
                th.setValue( (String) t);
                th.setId(parser.cont);
                parser.cont++;
                node.setChild(th);

                // BODY
                if (b!=null) node.setChild( (Node) b );

                parser.father = node;
                RESULT = node;
        :}
        | FOR:f PARIZQ ID ASSIGNMENT ID TO INT DELIMETER INT PARDER THEN:t BRACKETIZQ body:b BRACKETDER
        {:
                // for ( id = id to 10 | 1) then {}
                Node node = new Node();
                node.setTag("FOR_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // FOR
                Node for_s = new Node();
                for_s.setTag("FOR");
                for_s.setValue( (String) f);
                for_s.setId(parser.cont);
                parser.cont++;
                node.setChild(for_s);

                // FOR_PARAMETERS
                // node.setChild((Node)d);

                // THEN
                Node th = new Node();
                th.setTag("THEN");
                th.setValue( (String) t);
                th.setId(parser.cont);
                parser.cont++;
                node.setChild(th);

                // BODY
                if (b!=null) node.setChild( (Node) b );

                parser.father = node;
                RESULT = node;
        :}
        | FOR:f PARIZQ ID ASSIGNMENT ID TO ID DELIMETER INT PARDER THEN:t BRACKETIZQ body:b BRACKETDER
        {:
                // for ( id = id to id | 1) then {}
                Node node = new Node();
                node.setTag("FOR_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // FOR
                Node for_s = new Node();
                for_s.setTag("FOR");
                for_s.setValue( (String) f);
                for_s.setId(parser.cont);
                parser.cont++;
                node.setChild(for_s);

                // FOR_PARAMETERS
                // node.setChild((Node)d);

                // THEN
                Node th = new Node();
                th.setTag("THEN");
                th.setValue( (String) t);
                th.setId(parser.cont);
                parser.cont++;
                node.setChild(th);

                // BODY
                if (b!=null) node.setChild( (Node) b );

                parser.father = node;
                RESULT = node;
        :};

ifStatement ::= IF:i PARIZQ desicion:d PARDER THEN:t BRACKETIZQ body:b BRACKETDER
        {:
                // if () then {}
                Node node = new Node();
                node.setTag("IF_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // IF
                Node if_s = new Node();
                if_s.setTag("IF");
                if_s.setValue( (String) i);
                if_s.setId(parser.cont);
                parser.cont++;
                node.setChild(if_s);

                // DESICION
                node.setChild((Node)d);

                // THEN
                Node th = new Node();
                th.setTag("THEN");
                th.setValue( (String) t);
                th.setId(parser.cont);
                parser.cont++;
                node.setChild(th);

                // BODY
                if (b!=null) node.setChild( (Node) b );

                parser.father = node;
                RESULT = node;
        :}
        | IF:i PARIZQ desicion:d PARDER THEN:t BRACKETIZQ body:b BRACKETDER ELSE:e BRACKETIZQ body:bo BRACKETDER
        {:
                // if () then {} else {}
                Node node = new Node();
                node.setTag("IF_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // IF
                Node if_s = new Node();
                if_s.setTag("IF");
                if_s.setValue( (String) i);
                if_s.setId(parser.cont);
                parser.cont++;
                node.setChild(if_s);

                // DESICION
                node.setChild((Node)d);

                // THEN
                Node th = new Node();
                th.setTag("THEN");
                th.setValue( (String) t);
                th.setId(parser.cont);
                parser.cont++;
                node.setChild(th);

                // BODY
                if (b!=null) node.setChild( (Node) b );

                // ELSE
                Node es = new Node();
                es.setTag("ELSE");
                es.setValue( (String) e);
                es.setId(parser.cont);
                parser.cont++;
                node.setChild(es);

                if (bo!=null) node.setChild( (Node) bo );

                parser.father = node;
                RESULT = node;
        :}
        | IF:i PARIZQ desicion:d PARDER THEN:t BRACKETIZQ body:b BRACKETDER elseIf:ei
        {:
                // if () then {} else if () then {}
                Node node = new Node();
                node.setTag("IF_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // IF
                Node if_s = new Node();
                if_s.setTag("IF");
                if_s.setValue( (String) i);
                if_s.setId(parser.cont);
                parser.cont++;
                node.setChild(if_s);

                // DESICION
                node.setChild((Node)d);

                // THEN
                Node th = new Node();
                th.setTag("THEN");
                th.setValue( (String) t);
                th.setId(parser.cont);
                parser.cont++;
                node.setChild(th);

                // BODY
                if (b!=null) node.setChild( (Node) b );

                // ELSE IF
                node.setChild((Node)  ei);

                parser.father = node;
                RESULT = node;
        :};

elseIf ::= ELSE ifStatement:i
        {:
                Node node = new Node();
                node.setTag("ELSE_IF");
                node.setId(parser.cont);
                node.setChild( ((Node)i).getChildren() );
                parser.cont++;

                RESULT = node;
        :};

type ::= NUMBER:n
        {:
                Node node = new Node();
                node.setTag("TYPE");
                node.setValue((String)n);
                node.setId(parser.cont);
                parser.cont++;

                RESULT = node;
        :}
        | array_type:a
        {:
                
        :}
        | BOOLEAN:b
        {:
                Node node = new Node();
                node.setTag("TYPE");
                node.setValue((String)b);
                node.setId(parser.cont);
                parser.cont++;

                RESULT = node;
        :}       
        | CHARACTER:c
        {:
                Node node = new Node();
                node.setTag("TYPE");
                node.setValue((String)c);
                node.setId(parser.cont);
                parser.cont++;

                RESULT = node;
        :};           // Tipo de variable que pude ser una variable
array_type ::= ARRAY SBRACKETIZQ type SBRACKETDER;

return ::= COMEBACK:c PARIZQ value:v PARDER
        {:
                Node node = new Node();
                node.setTag("RETURN_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                Node co = new Node();
                co.setTag("COMEBACK");
                co.setValue((String)c);
                co.setId(parser.cont);
                parser.cont++;

                node.setChild(co);

                node.setChild((Node)v);

                RESULT = node;
        :};

desicion ::= value:v1 OPREL:o value:v2
        {:
                Node node = new Node();
                node.setTag("DECISION");
                node.setId(parser.cont);
                parser.cont++;

                node.setChild((Node)v1);
                
                Node op = new Node();
                op.setTag("RELATIONAL_OPERATOR");
                op.setValue((String)o);
                op.setId(parser.cont);
                parser.cont++;

                node.setChild(op);
                
                node.setChild((Node)v2);

                RESULT = node;
        :}
        | value: v
        {:      Node node = new Node();
                node.setTag("DECISION");
                node.setId(parser.cont);
                parser.cont++;

                node.setChild((Node)v);
                RESULT = node;
        :};
              


switchStatement ::= SWITCH PARIZQ ID PARDER BRACKETIZQ switch_body BRACKETDER;
switch_body ::=  case_switch DEFAULT COLON BRACKETIZQ body BRACKETDER;
case_switch ::= CASE PARIZQ value PARDER COLON BRACKETIZQ body BRACKETDER b_case_switch 
        | /*vacío*/; 
b_case_switch ::= case_switch;