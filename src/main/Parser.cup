package main;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;

parser code 
{:
    public static Node father;
    public int cont = 0;
    boolean errorFlag = false;

    int fila;
    int columna;

    @Override
    public Symbol scan() throws java.lang.Exception{
        Symbol sym = getScanner().next_token();
        fila = sym.left + 1;
        columna = sym.right + 1;
        return sym;
    }
        
    @Override
	public void report_error(String message, Object info) {
        System.err.print("Syntax error: " ); 
        expected();
        System.err.print("pero se encontro el token \'" + ((Symbol)info).value + "\' en la Linea: " + (((Symbol)info).left + 1) + ", Columna: " + (((Symbol)info).right + 1) + ". ");
        errorFlag = true;
    }

    @Override
	public void syntax_error(Symbol s){
        System.err.println("\nError Sintactico: " ); 
        expected();
        System.err.print("\tpero se encontro el token \'" + sym.terminalNames[s.sym] + "\'\n\tLinea: " + (s.left + 1) + "\tColumna: " + (s.right + 1) + "\n");
        errorFlag = true;
	}

    public void expected(){
        List<Integer> token_list = this.expected_token_ids();
        if (token_list.size() <= 0){
                token_list = this.expected_token_ids();
        }
        String expected_tokens = "";
        for (int i = 0 ; i < token_list.size(); i++){
                int id = token_list.get(i);
                if (id == 1){ 
                    continue;
                }
                String terminal_name = sym.terminalNames[id];
                if (i == token_list.size() - 1){
                    expected_tokens += terminal_name;
                }else{
                    expected_tokens += terminal_name + " , ";
                }
        }
        System.err.print("\tSe esperaba uno de los siguientes tokens: [" + expected_tokens + "] ");
    }

    public void report_fatal_error(String message, Object info) {
        errorFlag = true;
        System.err.print("Error Fatal:\nNo se pudo recuperar del problema.");
    }

    public void unrecovered_syntax_error(Symbol s) {
        errorFlag = true;
    }

    @Override
    public int error_sync_size(){
        errorFlag = true;
        return 1;
    }
    
:}


terminal String BOOL, CHAR, INT, EMPTY;
terminal MAIN, IF, THEN, ELSE, FOR, TO, WHILE, SWITCH, CASE, DEFAULT, FUNCTION, COMEBACK; 
terminal NUMBER, BOOLEAN, CHARACTER, INPUT, OUTPUT, OPREL, SUM, RES, MULT, CALL; 
terminal DIV, MOD, COLON, COMMA, PARDER, PARIZQ, BRACKETDER, BRACKETIZQ; 
terminal SBRACKETDER, SBRACKETIZQ, ASSIGNMENT, ID, DELIMETER, ARRAY;


// Principals non terminals
non terminal program, main, body;
non terminal proposition;
non terminal function;
non terminal function_list;

non terminal parameter;
non terminal b_parameter;

non terminal funCall_parameter;
non terminal b_funCall_parameter;

// Assignation and declaration
non terminal type;
non terminal array_type;

non terminal value;

non terminal aritmetic_expression ;
non terminal b_aritmetic_expression;
non terminal c_aritmetic_expression;
non terminal d_aritmetic_expression;

non terminal array_value;
non terminal b_array_value;
non terminal c_array_value;

non terminal sign;

// Statements
non terminal simpleDeclaration;
non terminal declarationAssignment;
non terminal assignment;

non terminal functionCall;
non terminal functionCallParameter;

non terminal outputStatement;
non terminal inputStatement;

non terminal desicion; // Desición para While y If

non terminal ifStatement;
non terminal else_n;
non terminal elseIf;

non terminal whileStatement;

non terminal for_parameter;
non terminal forStatement;

non terminal switchStatement;
non terminal switch_body;
non terminal case_switch_list;
non terminal case_switch;

non terminal return;

// GLCs para las funciones con retorno, ya que estas permiten hacer return en cualquier lado
non terminal func_body;

non terminal func_proposition;

non terminal func_ifStatement;
non terminal func_else_n;
non terminal func_elseIf;

non terminal func_whileStatement;

non terminal func_for_parameter;
non terminal func_forStatement;

non terminal func_switchStatement;
non terminal func_switch_body;
non terminal func_case_switch_list;
non terminal func_case_switch;



start with program;



// =======================================================>
// ============ Inicio del arbol =========================>
// =======================================================>
// Aquí inicia el programa, puede tener un main o varias funciones pero obligatoriamente tiene que tener un main
program ::= main:m function_list:fl
        {:      // CURRENT NODE
                Node node = new Node();
                node.setTag("INIT");
                node.setId(parser.cont);  
                parser.cont++;
                
                // MAIN
                node.setChild( (Node) m );

                // FUNCTION_LIST
                if(fl!=null) node.setChild((Node)fl);

                parser.father = node;
                RESULT = node;
        :};




// =======================================================>
// ============= Funcion Main ============================>
// =======================================================>
// GLC del main
main ::= FUNCTION MAIN:m PARIZQ PARDER ASSIGNMENT BRACKETIZQ body:b BRACKETDER
        {:      // CURRENT NODE
                Node node = new Node();
                node.setTag("MAIN");
                node.setId(parser.cont);
                parser.cont++;

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setId(parser.cont);
                id.setValue((String) m);
                node.setChild(id);

                // BODY
                if (b!=null) node.setChild( (Node) b );
                

                parser.father = node;
                RESULT = node;
        :}
        | FUNCTION error PARIZQ PARDER ASSIGNMENT BRACKETIZQ body:b BRACKETDER
        | FUNCTION MAIN:m error PARDER ASSIGNMENT BRACKETIZQ body:b BRACKETDER
        | FUNCTION MAIN:m PARIZQ error ASSIGNMENT BRACKETIZQ body:b BRACKETDER
        | FUNCTION MAIN:m PARIZQ PARDER error BRACKETIZQ body:b BRACKETDER
        | FUNCTION MAIN:m PARIZQ PARDER ASSIGNMENT error body:b BRACKETDER
        | FUNCTION MAIN:m PARIZQ PARDER ASSIGNMENT BRACKETIZQ body:b error;

// Este GLC contiene la lista de funciones
function_list ::= function:f function_list:fl
        {:      
                // CURRENT NODE
                Node node = new Node();
                node.setTag("FUNCTION_LIST");
                node.setId(parser.cont);
                parser.cont++;

                // FUNCTION
                node.setChild((Node)f);

                if(fl!=null) node.setChild( ((Node)fl).getChildren() );                      
                
                parser.father = node;
                RESULT = node;
        :} 
        | {:/*vacío*/:}
        | error function_list {:
            System.out.println("Function list error");
        :}; 





// =======================================================>
// ============ Funciones  ===============================>
// =======================================================>
// Estructura de la función, tiene recursividad para generar varias funciones
function ::= FUNCTION ID:i PARIZQ parameter:p PARDER ASSIGNMENT BRACKETIZQ body:b BRACKETDER
        {:      // CURRENT NODE
                Node node = new Node();
                node.setTag("FUNCTION");
                node.setId(parser.cont);
                parser.cont++;

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setId(parser.cont);
                parser.cont++;
                id.setValue( (String) i);
                node.setChild(id);

                // PARAMETER
                if (p!=null) node.setChild( (Node) p );
                
                // BODY
                if (b!=null) node.setChild( (Node) b );
                
                parser.father = node;
                RESULT = node;
        :}
        | FUNCTION ID:i PARIZQ parameter:p PARDER ASSIGNMENT type:t BRACKETIZQ func_body:b BRACKETDER
        {:
                // CURRENT NODE
                Node node = new Node();
                node.setTag("FUNCTION_WITH_RETURN");
                node.setId(parser.cont);
                parser.cont++;

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setId(parser.cont);
                parser.cont++;
                id.setValue( (String) i);
                node.setChild(id);
                
                // PARAMETER
                if (p!=null) node.setChild( (Node) p );
                
                // BODY
                if (b!=null) node.setChild((Node)b);


                parser.father = node;
                RESULT = node;
        :}
        | FUNCTION ID:i error parameter:p PARDER ASSIGNMENT BRACKETIZQ body:b BRACKETDER
        | FUNCTION ID:i PARIZQ parameter:p error ASSIGNMENT BRACKETIZQ body:b BRACKETDER
        | FUNCTION ID:i PARIZQ parameter:p PARDER error BRACKETIZQ body:b BRACKETDER
        | FUNCTION ID:i PARIZQ parameter:p PARDER ASSIGNMENT error body:b BRACKETDER
        | FUNCTION ID:i PARIZQ parameter:p PARDER ASSIGNMENT BRACKETIZQ body:b error
        
        | FUNCTION ID:i error parameter:p PARDER ASSIGNMENT type:t BRACKETIZQ func_body:b BRACKETDER
        | FUNCTION ID:i PARIZQ parameter:p error ASSIGNMENT type:t BRACKETIZQ func_body:b BRACKETDER
        | FUNCTION ID:i PARIZQ parameter:p PARDER error type:t BRACKETIZQ func_body:b BRACKETDER
        | FUNCTION ID:i PARIZQ parameter:p PARDER ASSIGNMENT type:t error func_body:b BRACKETDER
        | FUNCTION ID:i PARIZQ parameter:p PARDER ASSIGNMENT type:t BRACKETIZQ func_body:b error;






// =======================================================>
// ============ Parametros para las funciones ============>
// =======================================================>
// Parametro para las funciones al momento de hacerlas
parameter ::= b_parameter:b parameter:p
        {:
                // PROPOSITION
                Node node = new Node();
                node.setTag("PARAMETER_LIST");
                node.setId(parser.cont);
                parser.cont++;

                // PROPOSITION
                node.setChild( (Node) b );
        
                if(p!=null) node.setChild( ((Node)p).getChildren() );

                parser.father = node;
                RESULT = node;
        :}
        | {:/*vacío*/:}; 
b_parameter ::= ID:i COLON type:t 
        {:
                Node node = new Node();
                node.setTag("PARAMETER");
                node.setId(parser.cont++);
                parser.cont++;

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue( (String) i);
                id.setId(parser.cont++);
                parser.cont++;
                
                node.setChild(id);

                // TYPE
                node.setChild( (Node)t);
                
                parser.father = node;
                RESULT = node;
        :}
        | ID:i COLON type:t COMMA 
        {:
                Node node = new Node();
                node.setTag("PARAMETER");
                node.setId(parser.cont++);
                parser.cont++;

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue( (String) i);
                id.setId(parser.cont++);
                parser.cont++;
                
                node.setChild(id);

                // TYPE
                node.setChild( (Node)t);

                parser.father = node;
                RESULT = node;
        :};





// =======================================================>
// ============ Cuerpo ===================================>
// =======================================================>
// Aquí se encuentra el cuerpo de todo, se contienen las diversas proposiciones o Statements que
// Se puedan generar.
body ::= proposition:p body:b
        {:
                // PROPOSITION
                Node node = new Node();
                node.setTag("BODY");
                node.setId(parser.cont);
                parser.cont++;

                // PROPOSITION
                node.setChild( (Node) p );
                
                if(b!=null){
                        node.setChild( ((Node)b).getChildren() );
                }
                parser.father = node;
                RESULT = node;
        :}
        | {:/*Vacío*/:};






// =======================================================>
// ============ Proposiciones ============================>
// =======================================================>
proposition ::= simpleDeclaration: s
        {:
                Node node = (Node)s;
                parser.father = node;
                RESULT = node;
        :}
        | declarationAssignment:d
        {:
                Node node = (Node)d;
                parser.father = node;
                RESULT = node;
        :}
        | assignment:a
        {:
                Node node = (Node)a;
                parser.father = node;
                RESULT = node;
        :}
        | functionCall: f
        {:
                Node node = (Node)f;
                parser.father = node;
                RESULT = node;
        :}
        | functionCallParameter:fp
        {:
                Node node = (Node)fp;
                parser.father = node;
                RESULT = node;
        :}
        | outputStatement:o
        {:
                Node node = (Node)o;
                parser.father = node;
                RESULT = node;
        :}
        | inputStatement:i
        {:
                Node node = (Node)i;
                parser.father = node;
                RESULT = node;
        :}
        | ifStatement: i
        {:
                Node node = (Node)i;
                parser.father = node;
                RESULT = node;
        :}
        | whileStatement:w
        {:
                Node node = (Node)w;
                parser.father = node;
                RESULT = node;
        :}
        | forStatement:f 
        {:
                Node node = (Node)f;
                parser.father = node;
                RESULT = node;
        :}
        | switchStatement:s
        {:
                Node node = (Node)s;
                parser.father = node;
                RESULT = node;
        :};






// =======================================================>
// ============ Declaración simple =======================>
// =======================================================>
// Declaración simple del tipo number id
simpleDeclaration ::= type:t ID:i
        {:      
                // TYPE ID
                Node node = new Node();
                node.setTag("SIMPLE_DECLARATION");
                node.setId(parser.cont);
                parser.cont++;

                // TYPE
                node.setChild( (Node) t);

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue((String)i);
                id.setId(parser.cont);
                parser.cont++;

                node.setChild(id);

                parser.father = node;
                RESULT = node;
        :}
        | type:t error;






// =======================================================>
// ============ Declaración con asignación ===============>
// =======================================================>
// Declaración y al mismo tiempo una asignación de una variabletype:t ID:i ASSIGNMENT:a value:v
declarationAssignment ::=  type:t ID:i ASSIGNMENT:a value:v
        {:
                // TYPE ID = VALUE
                Node node = new Node();
                node.setTag("DECLARATION_ASSIGNATION");
                node.setId(parser.cont);
                parser.cont++;

                // TYPE
                node.setChild( (Node) t);

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue( (String) i);
                id.setId(parser.cont);
                parser.cont++;
                node.setChild(id);

                // ASSIGNMENT
                Node as = new Node();
                as.setTag("ASSIGNMENT");
                as.setValue( (String) a);
                as.setId(parser.cont);
                parser.cont++;
                node.setChild(as);

                // VALUE
                node.setChild( (Node) v);

                parser.father = node;
                RESULT = node;     
        :}
        | type:t ID:i ASSIGNMENT:a functionCall:f
        {:
                // TYPE ID = VALUE
                Node node = new Node();
                node.setTag("DECLARATION_ASSIGNATION");
                node.setId(parser.cont);
                parser.cont++;

                // TYPE
                node.setChild( (Node) t);

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue( (String) i);
                id.setId(parser.cont);
                parser.cont++;
                node.setChild(id);

                // ASSIGNMENT
                Node as = new Node();
                as.setTag("ASSIGNMENT");
                as.setValue( (String) a);
                as.setId(parser.cont);
                parser.cont++;
                node.setChild(as);

                // function Call
                node.setChild( (Node) f);

                parser.father = node;
                RESULT = node;   
        :}
        | type:t ID:i ASSIGNMENT:a functionCallParameter:f
        {:
                // TYPE ID = VALUE
                Node node = new Node();
                node.setTag("DECLARATION_ASSIGNATION");
                node.setId(parser.cont);
                parser.cont++;

                // TYPE
                node.setChild( (Node) t);

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue( (String) i);
                id.setId(parser.cont);
                parser.cont++;
                node.setChild(id);

                // ASSIGNMENT
                Node as = new Node();
                as.setTag("ASSIGNMENT");
                as.setValue( (String) a);
                as.setId(parser.cont);
                parser.cont++;
                node.setChild(as);

                // function Call
                node.setChild( (Node) f);

                parser.father = node;
                RESULT = node;   
        :}
        | type:t error ASSIGNMENT:a value:v
        | type:t error ASSIGNMENT:a functionCall:f;






// =======================================================>
// ============ Asignación ===============================>
// =======================================================>
// Asignación simple
assignment ::= ID:i ASSIGNMENT:a value:v
        {:
                // ID = VALUE
                Node node = new Node();
                node.setTag("ASSIGNMENT");
                node.setId(parser.cont);
                parser.cont++;

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue( (String) i);
                id.setId(parser.cont);
                node.setChild(id);

                // ASSIGNMENT
                Node as = new Node();
                as.setTag("ASSIGNMENT");
                as.setValue( (String) a);
                as.setId(parser.cont);
                parser.cont++;
                node.setChild(as);

                // VALUE
                node.setChild( (Node) v);

                parser.father = node;
                RESULT = node;   
        :}
        | ID:i ASSIGNMENT:a functionCall:f 
        {:
                // ID = VALUE
                Node node = new Node();
                node.setTag("ASSIGNMENT");
                node.setId(parser.cont);
                parser.cont++;

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue( (String) i);
                id.setId(parser.cont);
                node.setChild(id);

                // ASSIGNMENT
                Node as = new Node();
                as.setTag("ASSIGNMENT");
                as.setValue( (String) a);
                as.setId(parser.cont);
                parser.cont++;
                node.setChild(as);

                // FUNCTION CALL
                node.setChild( (Node) f);

                parser.father = node;
                RESULT = node;  
        :}
        | ID:i ASSIGNMENT:a functionCallParameter:f 
        {:
                // ID = VALUE
                Node node = new Node();
                node.setTag("ASSIGNMENT");
                node.setId(parser.cont);
                parser.cont++;

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue( (String) i);
                id.setId(parser.cont);
                node.setChild(id);

                // ASSIGNMENT
                Node as = new Node();
                as.setTag("ASSIGNMENT");
                as.setValue( (String) a);
                as.setId(parser.cont);
                parser.cont++;
                node.setChild(as);

                // FUNCTION CALL
                node.setChild( (Node) f);

                parser.father = node;
                RESULT = node;  
        :}
        | ID:i error value:v
        | ID:i error functionCall:f;





// =======================================================>
// ============ Llamada a una función ====================>
// =======================================================>
// Llamada a funciones sin parametros
functionCall ::= CALL ID:i PARIZQ PARDER 
        {:
                // CALL FUNCTION()
                Node node = new Node();
                node.setTag("FUNCTION_CALL");
                node.setId(parser.cont);
                parser.cont++;

                // CALL
                Node call = new Node();
                call.setTag("CALL");
                call.setId(parser.cont);
                parser.cont++;
                node.setChild(call);

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue((String)i);
                id.setId(parser.cont);
                parser.cont++;
                node.setChild(id);

                parser.father = node;
                RESULT = node;   
        :}
        | CALL error PARIZQ PARDER 
        | CALL ID:i error PARDER;






// =======================================================>
// ========= Llamada a una función con parametros ========>
// =======================================================>
// Llamada a funciones con parametros
functionCallParameter ::= CALL ID:i PARIZQ funCall_parameter:f PARDER
        {:
                // CALL FUNCTION( VALUE, VALUE2, VALUE3 )
                Node node = new Node();
                node.setTag("FUNCTION_CALL");
                node.setId(parser.cont);
                parser.cont++;

                // CALL
                Node call = new Node();
                call.setTag("CALL");
                call.setId(parser.cont);
                parser.cont++;
                node.setChild(call);

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue((String)i);
                id.setId(parser.cont);
                parser.cont++;
                node.setChild(id);

                // PARAMETERS
                node.setChild( (Node) f);
                
                parser.father = node;
                RESULT = node; 
        :}
        | CALL error PARIZQ funCall_parameter:f PARDER
        | CALL ID:i error funCall_parameter:f PARDER;






// =======================================================>
// ===================== Output ==========================>
// =======================================================>
// Para hacer el output, el output solamente permite los tipos de variables admitidos
outputStatement ::= OUTPUT:ou PARIZQ value:v PARDER 
        {:      
                // output(ID)
                Node node = new Node();
                node.setTag("OUTPUT_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // OUTPUT
                Node output = new Node();
                output.setTag("OUTPUT");
                output.setValue( (String) ou);
                output.setId(parser.cont);
                parser.cont++;
                node.setChild(output);

                // VALUE
                node.setChild((Node)v);

                parser.father = node;
                RESULT = node;
        :}
        | OUTPUT:ou error value:v PARDER ;






// =======================================================>
// ============== Input ==================================>
// =======================================================>
// Input del lenguaje funciona de la siguiente manera:
// ID = input()
inputStatement ::= ID:i ASSIGNMENT:a INPUT:ip PARIZQ PARDER 
        {:
                // id = input()
                Node node = new Node();
                node.setTag("INPUT_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setId(parser.cont);
                id.setValue( (String) i);
                parser.cont++;
                node.setChild(id);

                // ASSIGNMENT
                Node assignment = new Node();
                assignment.setTag("ASSIGNMENT");
                assignment.setValue( (String) a);
                assignment.setId(parser.cont);
                parser.cont++;
                node.setChild(assignment);

                // INPUT
                Node input = new Node();
                input.setTag("INPUT");
                input.setValue( (String) ip);
                input.setId(parser.cont);
                parser.cont++;
                node.setChild(input);

                parser.father = node;
                RESULT = node;
        :}
        | ID:i error INPUT:ip PARIZQ PARDER 
        | ID:i ASSIGNMENT:a error PARIZQ PARDER 
        | ID:i ASSIGNMENT:a INPUT:ip error PARDER ;






// =======================================================>
// ======================= IF ============================>
// =======================================================>
// Diferentes tipos de estructura del if
ifStatement ::= IF:i PARIZQ desicion:d PARDER THEN:t BRACKETIZQ body:b BRACKETDER
        {:
                // if () then {}
                Node node = new Node();
                node.setTag("IF_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // IF
                Node if_s = new Node();
                if_s.setTag("IF");
                if_s.setValue( (String) i);
                if_s.setId(parser.cont);
                parser.cont++;
                node.setChild(if_s);

                // DESICION
                node.setChild((Node)d);

                // THEN
                Node th = new Node();
                th.setTag("THEN");
                th.setValue( (String) t);
                th.setId(parser.cont);
                parser.cont++;
                node.setChild(th);

                // BODY
                if (b!=null) node.setChild( (Node) b );

                parser.father = node;
                RESULT = node;
        :}
        | IF:i PARIZQ desicion:d PARDER THEN:t BRACKETIZQ body:b BRACKETDER else_n:e
        {:
                // if () then {} else {}
                Node node = new Node();
                node.setTag("IF_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // IF
                Node if_s = new Node();
                if_s.setTag("IF");
                if_s.setValue( (String) i);
                if_s.setId(parser.cont);
                parser.cont++;
                node.setChild(if_s);

                // DESICION
                node.setChild((Node)d);

                // THEN
                Node th = new Node();
                th.setTag("THEN");
                th.setValue( (String) t);
                th.setId(parser.cont);
                parser.cont++;
                node.setChild(th);

                // BODY
                if (b!=null) node.setChild( (Node) b );

                // ELSE
                node.setChild( (Node) e);

                parser.father = node;
                RESULT = node;
        :}
        | IF:i PARIZQ desicion:d PARDER THEN:t BRACKETIZQ body:b BRACKETDER elseIf:ei
        {:
                // if () then {} else if () then {}
                Node node = new Node();
                node.setTag("IF_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // IF
                Node if_s = new Node();
                if_s.setTag("IF");
                if_s.setValue( (String) i);
                if_s.setId(parser.cont);
                parser.cont++;
                node.setChild(if_s);

                // DESICION
                node.setChild((Node)d);

                // THEN
                Node th = new Node();
                th.setTag("THEN");
                th.setValue( (String) t);
                th.setId(parser.cont);
                parser.cont++;
                node.setChild(th);

                // BODY
                if (b!=null) node.setChild( (Node) b );

                // ELSE IF
                node.setChild((Node)  ei);

                parser.father = node;
                RESULT = node;
        :}
        | IF:i error desicion:d PARDER THEN:t BRACKETIZQ body:b BRACKETDER
        | IF:i PARIZQ desicion:d error THEN:t BRACKETIZQ body:b BRACKETDER
        | IF:i PARIZQ desicion:d PARDER error BRACKETIZQ body:b BRACKETDER
        | IF:i PARIZQ desicion:d PARDER THEN:t error body:b BRACKETDER

        | IF:i error desicion:d PARDER THEN:t BRACKETIZQ body:b BRACKETDER else_n:e
        | IF:i PARIZQ desicion:d error THEN:t BRACKETIZQ body:b BRACKETDER else_n:e
        | IF:i PARIZQ desicion:d PARDER THEN:t error body:b BRACKETDER else_n:e
        | IF:i PARIZQ desicion:d PARDER error BRACKETIZQ body:b BRACKETDER else_n:e
        | IF:i PARIZQ desicion:d PARDER THEN:t BRACKETIZQ body:b error else_n:e

        | IF:i error desicion:d PARDER THEN:t BRACKETIZQ body:b BRACKETDER elseIf:ei
        | IF:i PARIZQ desicion:d error THEN:t BRACKETIZQ body:b BRACKETDER elseIf:ei
        | IF:i PARIZQ desicion:d PARDER error BRACKETIZQ body:b BRACKETDER elseIf:ei
        | IF:i PARIZQ desicion:d PARDER THEN:t error body:b BRACKETDER elseIf:ei
        | IF:i PARIZQ desicion:d PARDER THEN:t BRACKETIZQ body:b error elseIf:ei;
else_n ::=  ELSE:e BRACKETIZQ body:b BRACKETDER
        {:
                Node node = new Node();
                node.setTag("ELSE");
                node.setId(parser.cont);
                parser.cont++;
                if (b!=null) node.setChild( (Node) b );

                parser.father = node;
                RESULT = node;
        :};
elseIf ::= ELSE ifStatement:i
        {:
                Node node = new Node();
                node.setTag("ELSE_IF");
                node.setId(parser.cont);
                node.setChild( ((Node)i).getChildren() );
                parser.cont++;

                parser.father = node;
                RESULT = node;
        :};






// =======================================================>
// ======================= while =========================>
// =======================================================>
// Estructura del while
whileStatement ::= WHILE:w PARIZQ desicion:d PARDER THEN:t BRACKETIZQ body:b BRACKETDER 
        {:
                // while () then {}
                Node node = new Node();
                node.setTag("WHILE_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // WHILE
                Node wh_s = new Node();
                wh_s.setTag("WHILE");
                wh_s.setValue( (String) w);
                wh_s.setId(parser.cont);
                parser.cont++;
                node.setChild(wh_s);

                // DESICION
                node.setChild((Node)d);

                // THEN
                Node th = new Node();
                th.setTag("THEN");
                th.setValue( (String) t);
                th.setId(parser.cont);
                parser.cont++;
                node.setChild(th);

                // BODY
                if (b!=null) node.setChild( (Node) b );

                parser.father = node;
                RESULT = node;
        :}
        | WHILE:w error desicion:d PARDER THEN:t BRACKETIZQ body:b BRACKETDER
        | WHILE:w PARIZQ desicion:d error THEN:t BRACKETIZQ body:b BRACKETDER
        | WHILE:w PARIZQ desicion:d PARDER error BRACKETIZQ body:b BRACKETDER
        | WHILE:w PARIZQ desicion:d PARDER THEN:t error body:b BRACKETDER;






// =======================================================>
// ========================= For =========================>
// =======================================================>
// Estructura del for
forStatement ::= FOR:f PARIZQ for_parameter:d PARDER THEN:t BRACKETIZQ body:b BRACKETDER
        {:
                // for ( id = 0 to 10 | 1) then {}
                Node node = new Node();
                node.setTag("FOR_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // FOR
                Node for_s = new Node();
                for_s.setTag("FOR");
                for_s.setValue( (String) f);
                for_s.setId(parser.cont);
                parser.cont++;
                node.setChild(for_s);

                // FOR_PARAMETERS
                node.setChild((Node)d);

                // THEN
                Node th = new Node();
                th.setTag("THEN");
                th.setValue( (String) t);
                th.setId(parser.cont);
                parser.cont++;
                node.setChild(th);

                // BODY
                if (b!=null) node.setChild( (Node) b );

                parser.father = node;
                RESULT = node;
        :}
        | FOR:f error for_parameter:d PARDER THEN:t BRACKETIZQ body:b BRACKETDER
        | FOR:f PARIZQ for_parameter:d error THEN:t BRACKETIZQ body:b BRACKETDER
        | FOR:f PARIZQ for_parameter:d PARDER error BRACKETIZQ body:b BRACKETDER
        | FOR:f PARIZQ for_parameter:d PARDER THEN:t error body:b BRACKETDER;
for_parameter ::= ID:i ASSIGNMENT:a value:v1 TO:t value:v2 DELIMETER value:v3
        {:
                // NODO PADRE
                Node node = new Node();
                node.setTag("FOR_PARAMETER");
                node.setId(parser.cont);
                parser.cont++;

                // ASIGNMENT (NODO HIJO)
                Node assig = new Node();
                assig.setTag("ASSIGNMENT");
                assig.setId(parser.cont);
                parser.cont++;

                        // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue( (String) i);
                id.setId(parser.cont);
                parser.cont++;
                assig.setChild(id);

                        // ASSIGNMENT
                Node as_sign = new Node();
                as_sign.setTag("ASSIGNMENT");
                as_sign.setValue( (String) a);
                as_sign.setId(parser.cont);
                parser.cont++;
                assig.setChild(as_sign);

                        // VALUE
                assig.setChild( (Node) v1);

                node.setChild(assig);

                // TO
                Node to = new Node();
                to.setTag("TO");
                to.setValue((String)t);
                to.setId(parser.cont);
                parser.cont++;
                node.setChild(to);

                // VALUE 2
                node.setChild((Node)v2);

                // VALUE 3
                node.setChild((Node)v3);

                parser.father = node;
                RESULT = node;
        :}
        | ID:i error value:v1 TO:t value:v2 DELIMETER value:v3
        | ID:i ASSIGNMENT:a value:v1 error value:v2 DELIMETER value:v3
        | ID:i ASSIGNMENT:a value:v1 TO:t value:v2 error value:v3;






// =======================================================>
// ========================= Switch ======================>
// =======================================================>
// Estructura del switch case
switchStatement ::= SWITCH PARIZQ ID:i PARDER THEN:t BRACKETIZQ switch_body:sb BRACKETDER 
        {:      
                Node node = new Node();
                node.setTag("SWITCH_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;
                // SWITCH
                Node sw = new Node();
                sw.setTag("SWITCH");
                sw.setId(parser.cont);
                parser.cont++;

                node.setChild(sw);
                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue((String)i);
                id.setId(parser.cont);
                parser.cont++;

                node.setChild(id);
                
                Node th = new Node();
                th.setTag("THEN");
                th.setId(parser.cont);
                parser.cont++;

                node.setChild(th);

                // SWTICH BODY
                node.setChild((Node)sb);

                parser.father = node;
                RESULT = node;
        :}
        | SWITCH error ID:i PARDER THEN:t BRACKETIZQ switch_body:sb BRACKETDER 
        | SWITCH PARIZQ error PARDER THEN:t BRACKETIZQ switch_body:sb BRACKETDER 
        | SWITCH PARIZQ ID:i error THEN:t BRACKETIZQ switch_body:sb BRACKETDER 
        | SWITCH PARIZQ ID:i PARDER error BRACKETIZQ switch_body:sb BRACKETDER 
        | SWITCH PARIZQ ID:i PARDER THEN:t error switch_body:sb BRACKETDER ;
// Aqui está el cuerpo del swithcase que contiene su lista de casos y por default su case default
switch_body ::=  case_switch_list:c DEFAULT COLON BRACKETIZQ body:b BRACKETDER
        {:
                Node nodo = new Node();
                nodo.setTag("SWITCH_BODY");
                nodo.setId(parser.cont);
                parser.cont++;

                if (c!=null) nodo.setChild( ((Node)c).getChildren() );

                // DEFAULT CASE
                Node d_case = new Node();
                d_case.setTag("DEFAULT_CASE");
                d_case.setId(parser.cont++);
                parser.cont++;
                
                if (b!=null) d_case.setChild((Node)b);
                
                nodo.setChild(d_case);

                parser.father = nodo;
                RESULT = nodo;
        :}
        | case_switch_list:c error COLON BRACKETIZQ body:b BRACKETDER
        | case_switch_list:c DEFAULT error BRACKETIZQ body:b BRACKETDER
        | case_switch_list:c DEFAULT COLON error body:b BRACKETDER;
// Lista de casos que pueda tener un switch
case_switch_list ::=  case_switch:c  case_switch_list:cl
        {:
                Node node = new Node();
                node.setTag("CASE_LIST");
                node.setId(parser.cont++);
                parser.cont++;

                node.setChild( (Node) c);

                if (cl!=null) node.setChild( ((Node)cl).getChildren() );

                parser.father = node;
                RESULT = node;
        :}
        | /*vacío*/; 
// Estructura de cada switch
case_switch ::= CASE PARIZQ value:v PARDER COLON BRACKETIZQ body:b BRACKETDER
        {:
                Node node = new Node();
                node.setTag("CASE");
                node.setId(parser.cont);
                parser.cont++;

                node.setChild( (Node) v);    

                if(b!=null) node.setChild( (Node)b );  

                parser.father = node;
                RESULT = node;          
        :}
        | CASE error value:v PARDER COLON BRACKETIZQ body:b BRACKETDER
        | CASE PARIZQ value:v error COLON BRACKETIZQ body:b BRACKETDER
        | CASE PARIZQ value:v PARDER error BRACKETIZQ body:b BRACKETDER
        | CASE PARIZQ value:v PARDER COLON error body:b BRACKETDER;






// =======================================================>
// =========== Llamada a funcion con parametros ==========>
// =======================================================>
// Llamada a una función con parámetros
funCall_parameter ::= b_funCall_parameter:b funCall_parameter:fl
        {:
                Node node = new Node();
                node.setTag("FUNCTION_CALL_PARAMETERS");
                node.setId(parser.cont);
                parser.cont++;

                node.setChild( (Node)b);
                
                node.setChild( ((Node)fl).getChildren() );

                parser.father = node;
                RESULT = node;
        :}
        | value:v
        {:
                Node node = new Node();
                node.setTag("FUNCTION_CALL_PARAMETERS");
                node.setId(parser.cont);
                parser.cont++;

                node.setChild((Node)v);
        
                parser.father = node;
                RESULT = node;
        :};
b_funCall_parameter ::= value:v COMMA 
        {:      
                Node node = (Node)v;
                parser.father = node;
                RESULT = node;
        :}
        | value:v error ;






// =======================================================>
// ========================= Valores =====================>
// =======================================================>
// Tipos de valores que pueda tener una variable
value ::= ID:id
        {:
                Node node = new Node();
                node.setTag("ID");
                node.setValue((String)id);
                node.setId(parser.cont);
                parser.cont++;

                RESULT = node;
        :}
        | BOOL:b
        {:
                Node node = new Node();
                node.setTag("BOOLEAN");
                node.setValue((String)b);
                node.setId(parser.cont);
                parser.cont++;

                RESULT = node;
        :}
        | CHAR:c
        {:
                Node node = new Node();
                node.setTag("CHARACTER");
                node.setValue((String)c);
                node.setId(parser.cont);
                parser.cont++;

                RESULT = node;
        :}
        | EMPTY:e
        {:
                Node node = new Node();
                node.setTag("EMPTY");
                node.setValue((String)e);
                node.setId(parser.cont);
                parser.cont++;

                RESULT = node;
        :}                
        | array_value:av
        {:
                RESULT = (Node)av;
        :}
        | aritmetic_expression:a
        {:
                RESULT = (Node)a;
        :}
        | error;
aritmetic_expression ::= aritmetic_expression:a SUM:s b_aritmetic_expression:b
        {:
                Node node = new Node();
                node.setTag("SUMA");
                node.setId(parser.cont);
                parser.cont++;

                node.setChild( (Node)a );
                node.setChild( (Node)b );

                parser.father = node;
                RESULT = node;
        :}
        | aritmetic_expression:a RES:r b_aritmetic_expression:b
        {:
                Node node = new Node();
                node.setTag("RESTA");
                node.setId(parser.cont);
                parser.cont++;

                node.setChild( (Node)a );
                node.setChild( (Node)b );

                parser.father = node;
                RESULT = node;
        :}
        | b_aritmetic_expression:b 
        {:
                RESULT = (Node)b;
        :};
b_aritmetic_expression ::= b_aritmetic_expression:b MULT:t c_aritmetic_expression:c
        {:
                Node node = new Node();
                node.setTag("MULTIPLICACIÓN");
                node.setId(parser.cont);
                parser.cont++;

                node.setChild( (Node)b );
                node.setChild( (Node)c );

                parser.father = node;
                RESULT = node;   
        :}
        | b_aritmetic_expression:b DIV:div c_aritmetic_expression:c
        {:
                Node node = new Node();
                node.setTag("DIVISIÓN");
                node.setId(parser.cont);
                parser.cont++;

                node.setChild( (Node)b );
                node.setChild( (Node)c );

                parser.father = node;
                RESULT = node;  
        :}
        | c_aritmetic_expression:c
        {:
                RESULT = (Node)c;
        :};
c_aritmetic_expression ::= INT:i
        {:
                Node node = new Node();
                node.setTag("NUMBER");
                node.setValue((String)i);
                node.setId(parser.cont);
                parser.cont++;

                parser.father = node;
                RESULT = node;
        :}
        | PARIZQ:i aritmetic_expression:b PARDER:d
        {:
                RESULT = (Node)b;
        :};
// Este es el valor de un arreglo o una matriz
array_value ::= SBRACKETIZQ b_array_value:b SBRACKETDER
        {:
                Node node = new Node();
                node.setTag("ARRAY_VALUE");
                node.setId(parser.cont);
                parser.cont++;
                // node.setValue("["+((Node)av).getValue()+"]");
                node.setChild( ((Node)b).getChildren() );
                
                RESULT = node;
       :}
       |  SBRACKETIZQ b_array_value:b error;
b_array_value ::= c_array_value:c b_array_value:b
        {:
                Node node = new Node();
                node.setId(parser.cont);
                parser.cont++;

                // node.setValue( ((Node)c).getValue() + ((Node)b).getValue());
                node.setChild(((Node)c));
                node.setChild(((Node)b).getChildren());

                RESULT = node;
        :}
        | value:v
        {:
                Node node = new Node();

                node.setChild((Node)v);

                RESULT = node;
        :};
c_array_value ::= value:v COMMA
        {:
                RESULT = (Node)v;
        :};






// =======================================================>
// ========================= Tipos =======================>
// =======================================================>
// Tipos de variables
type ::= NUMBER:n
        {:
                Node node = new Node();
                node.setTag("TYPE");
                node.setValue((String)n);
                node.setId(parser.cont);
                parser.cont++;

                RESULT = node;
        :}
        | array_type:a
        {:
                Node node = new Node();
                node.setTag("TYPE");
                node.setValue( ((Node)a).getValue() );
                node.setId(parser.cont);
                parser.cont++;

                RESULT = node;
        :}
        | BOOLEAN:b
        {:
                Node node = new Node();
                node.setTag("TYPE");
                node.setValue((String)b);
                node.setId(parser.cont);
                parser.cont++;

                RESULT = node;
        :}       
        | CHARACTER:c
        {:
                Node node = new Node();
                node.setTag("TYPE");
                node.setValue((String)c);
                node.setId(parser.cont);
                parser.cont++;

                RESULT = node;
        :};           // Tipo de variable que pude ser una variable
array_type ::= ARRAY SBRACKETIZQ type:t SBRACKETDER
        {:
                Node node = new Node();
                node.setValue("array["+((Node)t).getValue()+"]");
                
                RESULT = node;
        :}
        | ARRAY error type:t SBRACKETDER;






// =======================================================>
// ======================== Return =======================>
// =======================================================>
// El return que solamente las funnciones que tengan el el tipo de variable a retornar especificado
return ::= COMEBACK:c PARIZQ value:v PARDER
        {:
                Node node = new Node();
                node.setTag("RETURN_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                Node co = new Node();
                co.setTag("COMEBACK");
                co.setValue((String)c);
                co.setId(parser.cont);
                parser.cont++;

                node.setChild(co);

                node.setChild((Node)v);

                parser.father = node;
                RESULT = node;
        :}
        | COMEBACK:c error value:v PARDER;






// =======================================================>
// ==================== Decisiones =======================>
// =======================================================>
// Desiciones que puede tener un if o un while
desicion ::= value:v1 OPREL:o value:v2
        {:
                Node node = new Node();
                node.setTag("DECISION");
                node.setId(parser.cont);
                parser.cont++;

                node.setChild((Node)v1);
                
                Node op = new Node();
                op.setTag("RELATIONAL_OPERATOR");
                op.setValue((String)o);
                op.setId(parser.cont);
                parser.cont++;

                node.setChild(op);
                
                node.setChild((Node)v2);

                parser.father = node;
                RESULT = node;
        :}
        | value: v
        {:      Node node = new Node();
                node.setTag("DECISION");
                node.setId(parser.cont);
                parser.cont++;

                node.setChild((Node)v);
                RESULT = node;
        :};






// <================================================================================================>
// <================================================================================================>
// <================================================================================================>
// <========= Los siguientes GLC Son exclusivas para los cuerpos de las funciones ==================>
// <================================================================================================>
// <================================================================================================>
// <================================================================================================>







// =======================================================>
// ==================== func_bod==========================>
// =======================================================>
func_body ::= func_proposition:p func_body:b
        {:
                // PROPOSITION
                Node node = new Node();
                node.setTag("BODY");
                node.setId(parser.cont);
                parser.cont++;

                // PROPOSITION
                node.setChild( (Node) p );
                
                if(b!=null){
                        node.setChild( ((Node)b).getChildren() );
                }
                parser.father = node;
                RESULT = node;
        :}
        | return:r func_body:b
        {:
                // PROPOSITION
                Node node = new Node();
                node.setTag("BODY");
                node.setId(parser.cont);
                parser.cont++;

                // PROPOSITION
                node.setChild( (Node) r );
                
                if(b!=null){
                        node.setChild( ((Node)b).getChildren() );
                }
                parser.father = node;
                RESULT = node;
        :}
        | {:/*Vacío*/:};






// =======================================================>
// ============ Proposiciones ============================>
// =======================================================>
func_proposition ::= simpleDeclaration: s
        {:
                Node node = (Node)s;
                parser.father = node;
                RESULT = node;
        :}
        | declarationAssignment:d
        {:
                Node node = (Node)d;
                parser.father = node;
                RESULT = node;
        :}
        | assignment:a
        {:
                Node node = (Node)a;
                parser.father = node;
                RESULT = node;
        :}
        | functionCall: f
        {:
                Node node = (Node)f;
                parser.father = node;
                RESULT = node;
        :}
        | functionCallParameter:fp
        {:
                Node node = (Node)fp;
                parser.father = node;
                RESULT = node;
        :}
        | outputStatement:o
        {:
                Node node = (Node)o;
                parser.father = node;
                RESULT = node;
        :}
        | inputStatement:i
        {:
                Node node = (Node)i;
                parser.father = node;
                RESULT = node;
        :}
        | func_ifStatement: i
        {:
                Node node = (Node)i;
                parser.father = node;
                RESULT = node;
        :}
        | func_whileStatement:w
        {:
                Node node = (Node)w;
                parser.father = node;
                RESULT = node;
        :}
        | func_forStatement:f 
        {:
                Node node = (Node)f;
                parser.father = node;
                RESULT = node;
        :}
        | func_switchStatement:s
        {:
                Node node = (Node)s;
                parser.father = node;
                RESULT = node;
        :};






// =======================================================>
// ======================= IF ============================>
// =======================================================>
// Diferentes tipos de estructura del if
func_ifStatement ::= IF:i PARIZQ desicion:d PARDER THEN:t BRACKETIZQ func_body:b BRACKETDER
        {:
                // if () then {}
                Node node = new Node();
                node.setTag("IF_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // IF
                Node if_s = new Node();
                if_s.setTag("IF");
                if_s.setValue( (String) i);
                if_s.setId(parser.cont);
                parser.cont++;
                node.setChild(if_s);

                // DESICION
                node.setChild((Node)d);

                // THEN
                Node th = new Node();
                th.setTag("THEN");
                th.setValue( (String) t);
                th.setId(parser.cont);
                parser.cont++;
                node.setChild(th);

                // BODY
                if (b!=null) node.setChild( (Node) b );

                parser.father = node;
                RESULT = node;
        :}
        | IF:i PARIZQ desicion:d PARDER THEN:t BRACKETIZQ func_body:b BRACKETDER func_else_n:e
        {:
                // if () then {} else {}
                Node node = new Node();
                node.setTag("IF_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // IF
                Node if_s = new Node();
                if_s.setTag("IF");
                if_s.setValue( (String) i);
                if_s.setId(parser.cont);
                parser.cont++;
                node.setChild(if_s);

                // DESICION
                node.setChild((Node)d);

                // THEN
                Node th = new Node();
                th.setTag("THEN");
                th.setValue( (String) t);
                th.setId(parser.cont);
                parser.cont++;
                node.setChild(th);

                // BODY
                if (b!=null) node.setChild( (Node) b );

                // ELSE
                node.setChild( (Node) e);

                parser.father = node;
                RESULT = node;
        :}
        | IF:i PARIZQ desicion:d PARDER THEN:t BRACKETIZQ func_body:b BRACKETDER func_elseIf:ei
        {:
                // if () then {} else if () then {}
                Node node = new Node();
                node.setTag("IF_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // IF
                Node if_s = new Node();
                if_s.setTag("IF");
                if_s.setValue( (String) i);
                if_s.setId(parser.cont);
                parser.cont++;
                node.setChild(if_s);

                // DESICION
                node.setChild((Node)d);

                // THEN
                Node th = new Node();
                th.setTag("THEN");
                th.setValue( (String) t);
                th.setId(parser.cont);
                parser.cont++;
                node.setChild(th);

                // BODY
                if (b!=null) node.setChild( (Node) b );

                // ELSE IF
                node.setChild((Node)  ei);

                parser.father = node;
                RESULT = node;
        :}
        | IF:i error desicion:d PARDER THEN:t BRACKETIZQ func_body:b BRACKETDER
        | IF:i PARIZQ desicion:d error THEN:t BRACKETIZQ func_body:b BRACKETDER
        | IF:i PARIZQ desicion:d PARDER THEN:t error func_body:b BRACKETDER
        
        | IF:i error desicion:d PARDER THEN:t BRACKETIZQ func_body:b BRACKETDER func_else_n:e
        | IF:i PARIZQ desicion:d error THEN:t BRACKETIZQ func_body:b BRACKETDER func_else_n:e
        | IF:i PARIZQ desicion:d PARDER THEN:t error func_body:b BRACKETDER func_else_n:e
        | IF:i PARIZQ desicion:d PARDER THEN:t BRACKETIZQ func_body:b error func_else_n:e
        
        | IF:i error desicion:d PARDER THEN:t BRACKETIZQ func_body:b BRACKETDER func_elseIf:ei
        | IF:i PARIZQ desicion:d error THEN:t BRACKETIZQ func_body:b BRACKETDER func_elseIf:ei
        | IF:i PARIZQ desicion:d PARDER THEN:t error func_body:b BRACKETDER func_elseIf:ei
        | IF:i PARIZQ desicion:d PARDER THEN:t BRACKETIZQ func_body:b error func_elseIf:ei;
func_else_n ::=  ELSE:e BRACKETIZQ func_body:b BRACKETDER
        {:
                Node node = new Node();
                node.setTag("ELSE");
                node.setId(parser.cont);
                parser.cont++;
                if (b!=null) node.setChild( (Node) b );

                parser.father = node;
                RESULT = node;
        :}
        | ELSE:e error func_body:b BRACKETDER;
func_elseIf ::= ELSE func_ifStatement:i
        {:
                Node node = new Node();
                node.setTag("ELSE_IF");
                node.setId(parser.cont);
                node.setChild( ((Node)i).getChildren() );
                parser.cont++;

                parser.father = node;
                RESULT = node;
        :};






// =======================================================>
// ======================= while =========================>
// =======================================================>
// Estructura del while
func_whileStatement ::= WHILE:w PARIZQ desicion:d PARDER THEN:t BRACKETIZQ func_body:b BRACKETDER 
        {:
                // while () then {}
                Node node = new Node();
                node.setTag("WHILE_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // WHILE
                Node wh_s = new Node();
                wh_s.setTag("WHILE");
                wh_s.setValue( (String) w);
                wh_s.setId(parser.cont);
                parser.cont++;
                node.setChild(wh_s);

                // DESICION
                node.setChild((Node)d);

                // THEN
                Node th = new Node();
                th.setTag("THEN");
                th.setValue( (String) t);
                th.setId(parser.cont);
                parser.cont++;
                node.setChild(th);

                // BODY
                if (b!=null) node.setChild( (Node) b );

                parser.father = node;
                RESULT = node;
        :}
        | WHILE:w error desicion:d PARDER THEN:t BRACKETIZQ func_body:b BRACKETDER 
        | WHILE:w PARIZQ desicion:d error THEN:t BRACKETIZQ func_body:b BRACKETDER 
        | WHILE:w PARIZQ desicion:d PARDER error BRACKETIZQ func_body:b BRACKETDER 
        | WHILE:w PARIZQ desicion:d PARDER THEN:t error func_body:b BRACKETDER ;






// =======================================================>
// ========================= For =========================>
// =======================================================>
// Estructura del for
func_forStatement ::= FOR:f PARIZQ func_for_parameter:d PARDER THEN:t BRACKETIZQ func_body:b BRACKETDER
        {:
                // for ( id = 0 to 10 | 1) then {}
                Node node = new Node();
                node.setTag("FOR_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;

                // FOR
                Node for_s = new Node();
                for_s.setTag("FOR");
                for_s.setValue( (String) f);
                for_s.setId(parser.cont);
                parser.cont++;
                node.setChild(for_s);

                // FOR_PARAMETERS
                node.setChild((Node)d);

                // THEN
                Node th = new Node();
                th.setTag("THEN");
                th.setValue( (String) t);
                th.setId(parser.cont);
                parser.cont++;
                node.setChild(th);

                // BODY
                if (b!=null) node.setChild( (Node) b );

                parser.father = node;
                RESULT = node;
        :}
        | FOR:f error func_for_parameter:d PARDER THEN:t BRACKETIZQ func_body:b BRACKETDER
        | FOR:f PARIZQ func_for_parameter:d error THEN:t BRACKETIZQ func_body:b BRACKETDER
        | FOR:f PARIZQ func_for_parameter:d PARDER error BRACKETIZQ func_body:b BRACKETDER
        | FOR:f PARIZQ func_for_parameter:d PARDER THEN:t error func_body:b BRACKETDER;
func_for_parameter ::= ID:i ASSIGNMENT:a value:v1 TO:t value:v2 DELIMETER value:v3
        {:
                // NODO PADRE
                Node node = new Node();
                node.setTag("FOR_PARAMETER");
                node.setId(parser.cont);
                parser.cont++;

                // ASIGNMENT (NODO HIJO)
                Node assig = new Node();
                assig.setTag("ASSIGNMENT");
                assig.setId(parser.cont);
                parser.cont++;

                        // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue( (String) i);
                id.setId(parser.cont);
                parser.cont++;
                assig.setChild(id);

                        // ASSIGNMENT
                Node as_sign = new Node();
                as_sign.setTag("ASSIGNMENT");
                as_sign.setValue( (String) a);
                as_sign.setId(parser.cont);
                parser.cont++;
                assig.setChild(as_sign);

                        // VALUE
                assig.setChild( (Node) v1);

                node.setChild(assig);

                // TO
                Node to = new Node();
                to.setTag("TO");
                to.setValue((String)t);
                to.setId(parser.cont);
                parser.cont++;
                node.setChild(to);

                // VALUE 2
                node.setChild((Node)v2);

                // VALUE 3
                node.setChild((Node)v3);

                parser.father = node;
                RESULT = node;
        :}
        |  ID:i error value:v1 TO:t value:v2 DELIMETER value:v3
        |  ID:i ASSIGNMENT:a value:v1 error value:v2 DELIMETER value:v3
        |  ID:i ASSIGNMENT:a value:v1 TO:t value:v2 error value:v3;






// =======================================================>
// ========================= Switch ======================>
// =======================================================>
// Estructura del switch case
func_switchStatement ::= SWITCH PARIZQ ID:i PARDER THEN:t BRACKETIZQ func_switch_body:sb BRACKETDER 
        {:      
                Node node = new Node();
                node.setTag("SWITCH_STATEMENT");
                node.setId(parser.cont);
                parser.cont++;
                // SWITCH
                Node sw = new Node();
                sw.setTag("SWITCH");
                sw.setId(parser.cont);
                parser.cont++;

                node.setChild(sw);
                // ID
                Node id = new Node();
                id.setTag("ID");
                id.setValue((String)i);
                id.setId(parser.cont);
                parser.cont++;

                node.setChild(id);
                
                Node th = new Node();
                th.setTag("THEN");
                th.setId(parser.cont);
                parser.cont++;

                node.setChild(th);

                // SWTICH BODY
                node.setChild((Node)sb);

                parser.father = node;
                RESULT = node;
        :}
        |  SWITCH error ID:i PARDER THEN:t BRACKETIZQ func_switch_body:sb BRACKETDER 
        |  SWITCH PARIZQ error PARDER THEN:t BRACKETIZQ func_switch_body:sb BRACKETDER 
        |  SWITCH PARIZQ ID:i error THEN:t BRACKETIZQ func_switch_body:sb BRACKETDER 
        |  SWITCH PARIZQ ID:i PARDER error BRACKETIZQ func_switch_body:sb BRACKETDER 
        |  SWITCH PARIZQ ID:i PARDER THEN:t error func_switch_body:sb BRACKETDER ;
// Aqui está el cuerpo del swithcase que contiene su lista de casos y por default su case default
func_switch_body ::= func_case_switch_list:c DEFAULT COLON BRACKETIZQ func_body:b BRACKETDER
        {:
                Node nodo = new Node();
                nodo.setTag("SWITCH_BODY");
                nodo.setId(parser.cont);
                parser.cont++;

                if (c!=null) nodo.setChild( ((Node)c).getChildren() );

                // DEFAULT CASE
                Node d_case = new Node();
                d_case.setTag("DEFAULT_CASE");
                d_case.setId(parser.cont++);
                parser.cont++;
                
                if (b!=null) d_case.setChild((Node)b);
                
                nodo.setChild(d_case);

                parser.father = nodo;
                RESULT = nodo;
        :}
        |  func_case_switch_list:c error COLON BRACKETIZQ func_body:b BRACKETDER
        |  func_case_switch_list:c DEFAULT error BRACKETIZQ func_body:b BRACKETDER
        |  func_case_switch_list:c DEFAULT COLON error func_body:b BRACKETDER;
// Lista de casos que pueda tener un switch
func_case_switch_list ::=  func_case_switch:c  func_case_switch_list:cl
        {:
                Node node = new Node();
                node.setTag("CASE_LIST");
                node.setId(parser.cont++);
                parser.cont++;

                node.setChild( (Node) c);

                if (cl!=null) node.setChild( ((Node)cl).getChildren() );

                parser.father = node;
                RESULT = node;
        :}
        | /*vacío*/; 
// Estructura de cada switch
func_case_switch ::= CASE PARIZQ value:v PARDER COLON BRACKETIZQ func_body:b BRACKETDER
        {:
                Node node = new Node();
                node.setTag("CASE");
                node.setId(parser.cont);
                parser.cont++;

                node.setChild( (Node) v);    

                if(b!=null) node.setChild( (Node)b );  

                parser.father = node;
                RESULT = node;          
        :}
        |  CASE error value:v PARDER COLON BRACKETIZQ func_body:b BRACKETDER
        |  CASE PARIZQ value:v error COLON BRACKETIZQ func_body:b BRACKETDER
        |  CASE PARIZQ value:v PARDER error BRACKETIZQ func_body:b BRACKETDER
        |  CASE PARIZQ value:v PARDER COLON error func_body:b BRACKETDER;