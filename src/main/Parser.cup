package main;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;

parser code 
{:
    public static Node father;
    public int cont = 0;
    public static int errores = 0;

    public void syntax_error(Symbol s){ 
       System.out.println("Error Sintáctico en la Línea " + (s.left) +
        " Columna "+s.right+ ". No se esperaba este componente: " +s.value+".");
       System.out.println("Sintaxis truena");
    } 

    /* public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println("CUP detecto un error de syntaxis en " + s.left + " column " + s.right);
    } */
:}


terminal String BOOL, CHAR, INT, EMPTY;
terminal MAIN, IF, THEN, ELSE, FOR, TO, WHILE, SWITCH, CASE, DEFAULT, FUNCTION, COMEBACK; 
terminal NUMBER, BOOLEAN, CHARACTER, INPUT, OUTPUT, OPREL, SUM, RES, MULT, CALL; 
terminal DIV, MOD, SEMICOLON, COLON, COMMA, PARDER, PARIZQ, BRACKETDER, BRACKETIZQ; 
terminal SBRACKETDER, SBRACKETIZQ, ASSIGNMENT, ID, DELIMETER, ARRAY;


// Principals non terminals
non terminal program, main, body, b_body;
non terminal proposition;
non terminal function;
non terminal function_list;

non terminal parameter;
non terminal b_parameter;

non terminal functionCall;
non terminal funCall_parameter;
non terminal b_funCall_parameter;

// Asignation and declaration
non terminal type;
non terminal array_type;
non terminal simpleDeclaration;
non terminal declaration_assign;
non terminal assignment;
non terminal value;
non terminal aritmetic_expression ;
non terminal b_aritmetic_expression;
non terminal c_aritmetic_expression;
non terminal signo;
non terminal array_value;

// Statements
non terminal whileStatement;
non terminal ifStatement;
non terminal desicion; // Desición para While y If
non terminal outputStatement;
non terminal inputStatement;
non terminal forStatement;
non terminal switchStatement;
non terminal switch_body;
non terminal case_switch;
non terminal b_case_switch;
non terminal return;

start with program;


program ::= main:i function_list:fi 
        {:
                Node node = new Node();
                node.setTag("INITIALIZE");
                node.setId(parser.cont);  
                parser.cont++;

                node.setChild( (Node) i );
                node.setChild( (Node) fi );
                parser.father = node;
                RESULT = node;
        :}
        | main:i 
        {:
                /* Node node = new Node();
                node.setTag("INITIALIZE");
                node.setId(parser.cont);
                parser.cont++;

                node.setChild( (Node) i );
                RESULT = node; */
        
        :};  // SI FUNCIONA >:C

main ::= FUNCTION MAIN PARIZQ PARDER ASSIGNMENT BRACKETIZQ body BRACKETDER;

function_list ::= FUNCTION ID PARIZQ parameter PARDER ASSIGNMENT BRACKETIZQ body BRACKETDER function |
                  FUNCTION ID PARIZQ parameter PARDER ASSIGNMENT type BRACKETIZQ body return BRACKETDER function;   // Este GLC permite múltiples funciones
function ::= function_list
        | /*vacío*/;

parameter ::= b_parameter 
        | /*vacío*/;        // GLC para el parámetro que contienen las funciones  
b_parameter ::= ID COLON type 
        | ID COLON type COMMA parameter;

body ::= proposition b_body 
        | /*vacío*/;    // Este GLC permite
b_body ::= body;    // múltiples proposiciones

proposition ::= simpleDeclaration      
        | declaration_assign
        | assignment
        | functionCall
        | outputStatement
        | inputStatement
        | ifStatement
        | whileStatement
        | forStatement
        | switchStatement;      // Este GLC contiene los diferentes statements
functionCall ::= CALL ID PARIZQ PARDER
        | CALL ID PARIZQ funCall_parameter PARDER;

funCall_parameter ::= b_funCall_parameter
        | value;
b_funCall_parameter ::= value COMMA funCall_parameter;

simpleDeclaration ::= type ID;  // Declaración simple con el tipo de variable y la ID

declaration_assign ::= type ID ASSIGNMENT value;        // Declaración con asignación incluida

assignment ::= ID ASSIGNMENT value;     // Solamente asignación

signo ::= SUM
        | RES
        | DIV
        | MULT
        | MOD;
value ::= ID
        | BOOL
        | CHAR
        | EMPTY                
        | array_value
        | INT;              // Tipo de valor que pueda contener una expresión

/* aritmetic_expression ::= INT b_aritmetic_expression
        | PARIZQ INT b_aritmetic_expression PARDER c_aritmetic_expression;
b_aritmetic_expression ::= signo aritmetic_expression
        | {::} ;

c_aritmetic_expression ::= b_aritmetic_expression; */

type ::= NUMBER
        | array_type
        | BOOLEAN       
        | CHARACTER;           // Tipo de variable que pude ser una variable
array_type ::= ARRAY SBRACKETIZQ type SBRACKETDER;

return ::= COMEBACK value;

outputStatement ::= OUTPUT PARIZQ value PARDER;

inputStatement ::= ID ASSIGNMENT INPUT PARIZQ PARDER;

ifStatement ::= IF PARIZQ desicion PARDER THEN BRACKETIZQ body BRACKETDER
        | IF PARIZQ desicion PARDER THEN BRACKETIZQ body BRACKETDER ELSE BRACKETIZQ body BRACKETDER
        | IF PARIZQ desicion PARDER THEN BRACKETIZQ body BRACKETDER ELSE ifStatement;

whileStatement ::= WHILE PARIZQ desicion PARDER BRACKETIZQ body BRACKETDER;
desicion ::= BOOL
        | INT
        | ID
        | ID OPREL INT
        | ID OPREL CHAR
        | ID OPREL BOOL
        | ID OPREL ID;

forStatement ::= FOR PARIZQ ID ASSIGNMENT INT TO INT DELIMETER INT PARDER BRACKETIZQ body BRACKETDER
        | FOR PARIZQ ID ASSIGNMENT ID TO INT DELIMETER INT PARDER BRACKETIZQ body BRACKETDER
        | FOR PARIZQ ID ASSIGNMENT ID TO ID DELIMETER INT PARDER BRACKETIZQ body BRACKETDER;

switchStatement ::= SWITCH PARIZQ ID PARDER BRACKETIZQ switch_body BRACKETDER;
switch_body ::=  case_switch DEFAULT COLON BRACKETIZQ body BRACKETDER;
case_switch ::= CASE PARIZQ value PARDER COLON BRACKETIZQ body BRACKETDER b_case_switch 
        | /*vacío*/; 
b_case_switch ::= case_switch;